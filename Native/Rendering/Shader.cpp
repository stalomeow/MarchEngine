#include "Rendering/Shader.h"
#include "Core/Debug.h"
#include "Core/StringUtility.h"
#include <d3d12shader.h>    // Shader reflection.

using namespace Microsoft::WRL;

namespace dx12demo
{
    void Shader::Compile(const std::string& filename, const std::string& entrypoint, const std::string& targetProfile)
    {
        // https://github.com/microsoft/DirectXShaderCompiler/wiki/Using-dxc.exe-and-dxcompiler.dll

        // 
        // Create compiler and utils.
        //
        ComPtr<IDxcUtils> pUtils;
        ComPtr<IDxcCompiler3> pCompiler;
        DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
        DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

        //
        // Create default include handler. (You can create your own...)
        //
        ComPtr<IDxcIncludeHandler> pIncludeHandler;
        pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

        std::wstring wFilename = StringUtility::Utf8ToUtf16(filename);
        std::wstring wEntrypoint = StringUtility::Utf8ToUtf16(entrypoint);
        std::wstring wTargetProfile = StringUtility::Utf8ToUtf16(targetProfile);

        LPCWSTR pszArgs[] =
        {
            wFilename.c_str(),                     // Optional shader source file name for error reporting and for PIX shader source view.  
            L"-E", wEntrypoint.c_str(),            // Entry point.
            L"-T", wTargetProfile.c_str(),         // Target.
            L"-Zs",                                // Enable debug information (slim format)
            // L"-D", L"MYDEFINE=1",               // A single define.
            L"-Fo", (wFilename + L".bin").c_str(), // Optional. Stored in the pdb. 
            L"-Fd", (wFilename + L".pdb").c_str(), // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
            L"-Qstrip_reflect",                    // Strip reflection into a separate blob. 
        };

        //
        // Open source file.
        //
        ComPtr<IDxcBlobEncoding> pSource = nullptr;
        pUtils->LoadFile(wFilename.c_str(), nullptr, &pSource);
        DxcBuffer Source = {};
        Source.Ptr = pSource->GetBufferPointer();
        Source.Size = pSource->GetBufferSize();
        Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

        //
        // Compile it with specified arguments.
        //
        ComPtr<IDxcResult> pResults;
        pCompiler->Compile(
            &Source,                // Source buffer.
            pszArgs,                // Array of pointers to arguments.
            _countof(pszArgs),      // Number of arguments.
            pIncludeHandler.Get(),  // User-provided interface to handle #include directives (optional).
            IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
        );

        //
        // Print errors if present.
        //
        ComPtr<IDxcBlobUtf8> pErrors = nullptr;
        pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
        // Note that d3dcompiler would return null if no errors or warnings are present.
        // IDxcCompiler3::Compile will always return an error buffer, but its length
        // will be zero if there are no warnings or errors.
        if (pErrors != nullptr && pErrors->GetStringLength() != 0)
        {
            DEBUG_LOG_ERROR("Compilation Failed; Warnings and Errors:\n%s\n", pErrors->GetStringPointer());
        }

        //
        // Quit if the compilation failed.
        //
        HRESULT hrStatus;
        pResults->GetStatus(&hrStatus);
        if (FAILED(hrStatus))
        {
            return;
        }

        //
        // Save shader binary.
        //
        ComPtr<IDxcBlob> pShader = nullptr;
        ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
        pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName);
        if (pShader != nullptr)
        {
            FILE* fp = NULL;

            _wfopen_s(&fp, pShaderName->GetStringPointer(), L"wb");
            fwrite(pShader->GetBufferPointer(), pShader->GetBufferSize(), 1, fp);
            fclose(fp);
        }

        //
        // Save pdb.
        //
        ComPtr<IDxcBlob> pPDB = nullptr;
        ComPtr<IDxcBlobUtf16> pPDBName = nullptr;
        pResults->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&pPDB), &pPDBName);
        {
            FILE* fp = NULL;

            // Note that if you don't specify -Fd, a pdb name will be automatically generated.
            // Use this file name to save the pdb so that PIX can find it quickly.
            _wfopen_s(&fp, pPDBName->GetStringPointer(), L"wb");
            fwrite(pPDB->GetBufferPointer(), pPDB->GetBufferSize(), 1, fp);
            fclose(fp);
        }

        //
        // Print hash.
        //
        ComPtr<IDxcBlob> pHash = nullptr;
        pResults->GetOutput(DXC_OUT_SHADER_HASH, IID_PPV_ARGS(&pHash), nullptr);
        if (pHash != nullptr)
        {
            wprintf(L"Hash: ");
            DxcShaderHash* pHashBuf = (DxcShaderHash*)pHash->GetBufferPointer();
            for (int i = 0; i < _countof(pHashBuf->HashDigest); i++)
                wprintf(L"%.2x", pHashBuf->HashDigest[i]);
            wprintf(L"\n");
        }

        //
        // Demonstrate getting the hash from the PDB blob using the IDxcUtils::GetPDBContents API
        //
        ComPtr<IDxcBlob> pHashDigestBlob = nullptr;
        ComPtr<IDxcBlob> pDebugDxilContainer = nullptr;
        if (SUCCEEDED(pUtils->GetPDBContents(pPDB.Get(), &pHashDigestBlob, &pDebugDxilContainer)))
        {
            // This API returns the raw hash digest, rather than a DxcShaderHash structure.
            // This will be the same as the DxcShaderHash::HashDigest returned from
            // IDxcResult::GetOutput(DXC_OUT_SHADER_HASH, ...).
            wprintf(L"Hash from PDB: ");
            const BYTE* pHashDigest = (const BYTE*)pHashDigestBlob->GetBufferPointer();
            assert(pHashDigestBlob->GetBufferSize() == 16); // hash digest is always 16 bytes.
            for (int i = 0; i < pHashDigestBlob->GetBufferSize(); i++)
                wprintf(L"%.2x", pHashDigest[i]);
            wprintf(L"\n");

            // The pDebugDxilContainer blob will contain a DxilContainer formatted
            // binary, but with different parts than the pShader blob retrieved
            // earlier.
            // The parts in this container will vary depending on debug options and
            // the compiler version.
            // This blob is not meant to be directly interpreted by an application.
        }

        //
        // Get separate reflection.
        //
        ComPtr<IDxcBlob> pReflectionData;
        pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
        if (pReflectionData != nullptr)
        {
            // Optionally, save reflection blob for later here.

            // Create reflection interface.
            DxcBuffer ReflectionData;
            ReflectionData.Encoding = DXC_CP_ACP;
            ReflectionData.Ptr = pReflectionData->GetBufferPointer();
            ReflectionData.Size = pReflectionData->GetBufferSize();

            ComPtr<ID3D12ShaderReflection> pReflection;
            pUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(&pReflection));

            // Use reflection interface here.
        }
    }
}
