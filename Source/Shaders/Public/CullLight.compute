#pragma kernel ResetMain
#pragma kernel CullClusterMain
#pragma kernel CullLightMain

#define LIGHT_CULLING
#include "Includes/Lighting.hlsl"
#include "Includes/GBuffer.hlsl"

RWStructuredBuffer<int> _VisibleLightCounter;
RWStructuredBuffer<int> _MaxClusterZIds;

[numthreads(256, 1, 1)]
void ResetMain(int3 dtid : SV_DispatchThreadID)
{
    if (dtid.x == 0)
    {
        _VisibleLightCounter[0] = 0;
    }

    if (dtid.x < _NumClusters.x * _NumClusters.y)
    {
        _MaxClusterZIds[dtid.x] = -1;
    }
}

[numthreads(16, 16, 1)]
void CullClusterMain(int3 dtid : SV_DispatchThreadID)
{
    float width, height;
    GetDepthGBufferDimensions(width, height);

    if (dtid.x >= width || dtid.y >= height)
    {
        return;
    }

    // TODO 速度太慢，之后从 Hi-Z buffer 里读取深度

    GBufferData gbuffer = LoadGBufferData(dtid.xy);
    float2 uv = float2(dtid.x / width, dtid.y / height);
    float3 positionVS = ComputeViewSpacePosition(uv, gbuffer.depth);
    int3 clusterId = GetClusterId(uv, positionVS);

    // 记录每个 clusterId.xy 对应的最大 clusterId.z，记录最远的 cluster
    InterlockedMax(_MaxClusterZIds[GetClusterIndex(int3(clusterId.xy, 0))], clusterId.z);
}

bool IsPointLightVisible(float3 lightPositionVS, LightRawData light, ClusterFrustum f)
{
    float4 p = float4(lightPositionVS, 1.0);

    [unroll]
    for (int j = 0; j < 6; j++)
    {
        if (dot(f.planes[j], p) < -light.params.x)
        {
            return false;
        }
    }

    return true;
}

bool IsSpotLightVisible(float3 lightPositionVS, LightRawData light, ClusterFrustum f)
{
    // 先检查距离，再检查角度

    if (!IsPointLightVisible(lightPositionVS, light, f))
    {
        return false;
    }

    // Ref: https://bartwronski.com/2017/04/13/cull-that-cone/

    float3 spotDirVS = normalize(TransformWorldToViewDir(-light.spotDirection.xyz));
    float3 lightToFrustumVS = f.sphere.xyz - lightPositionVS.xyz;
    float distSq = dot(lightToFrustumVS, lightToFrustumVS);
    float distProj = dot(spotDirVS, lightToFrustumVS);
    float cosAngle = light.params.y;
    float sinAngle = sqrt(1 - cosAngle * cosAngle);
    float distClosestPoint = cosAngle * sqrt(distSq - distProj * distProj) - distProj * sinAngle;

    bool angleCull = distClosestPoint > f.sphere.w;
    bool backCull = distProj < -f.sphere.w;
    return !(angleCull || backCull);
}

int AllocateClusterLightIndicesRange(inout int numLights)
{
    int startIndex;
    InterlockedAdd(_VisibleLightCounter[0], numLights, startIndex);

    uint numMaxIndices, _;
    _ClusterPunctualLightIndices.GetDimensions(numMaxIndices, _);

    numLights = min(numLights, (int) numMaxIndices - startIndex);

    if (numLights <= 0)
    {
        numLights = 0;
        return 0;
    }

    return startIndex;
}

#define NUM_MAX_LIGHT_IN_CLUSTER 100

[numthreads(8, 8, 4)]
void CullLightMain(int3 dtid : SV_DispatchThreadID)
{
    if (any(dtid >= _NumClusters.xyz))
    {
        return;
    }

    int numLights = 0;
    int lights[NUM_MAX_LIGHT_IN_CLUSTER];
    int clusterIndex = GetClusterIndex(dtid);

    // cluster 不被遮挡时，才进行光源剔除
    if (dtid.z <= _MaxClusterZIds[GetClusterIndex(int3(dtid.xy, 0))])
    {
        ClusterFrustum f = GetClusterViewSpaceFrustum(dtid);

        for (int i = 0; i < GetNumPunctualLights() && numLights < NUM_MAX_LIGHT_IN_CLUSTER; i++)
        {
            bool visible;
            LightRawData light = _PunctualLights[i];
            float3 positionVS = TransformWorldToView(light.position.xyz);

            if (light.params.w == 1)
            {
                visible = IsSpotLightVisible(positionVS, light, f);
            }
            else
            {
                visible = IsPointLightVisible(positionVS, light, f);
            }

            if (visible)
            {
                lights[numLights++] = i;
            }
        }
    }

    int startIndex = AllocateClusterLightIndicesRange(numLights);
    _ClusterPunctualLightRanges[clusterIndex] = int2(startIndex, numLights);

    for (int i = 0; i < numLights; i++)
    {
        _ClusterPunctualLightIndices[startIndex + i] = lights[i];
    }
}
