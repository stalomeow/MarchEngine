#pragma kernel CopyDepthMain
#pragma kernel GenMipMain

#include "Includes/Common.hlsl"

Texture2D _InputTexture;
RWTexture2D<float> _OutputTexture;

[numthreads(16, 16, 1)]
void CopyDepthMain(int3 dtid : SV_DispatchThreadID)
{
    _OutputTexture[dtid.xy] = _InputTexture.Load(int3(dtid.xy, 0)).r;
}

[numthreads(16, 16, 1)]
void GenMipMain(int3 dtid : SV_DispatchThreadID)
{
    int width, height;
    _InputTexture.GetDimensions(width, height);

    int2 location = dtid.xy * 2;
    float2 uv = (location + 1.0) / float2(width, height); // 采样四个像素的中心
    float4 depth = _InputTexture.GatherRed(sampler_LinearClamp, uv);
    float nearest = GetNearestDepth(GetNearestDepth(depth.x, depth.y), GetNearestDepth(depth.z, depth.w));

    // 奇数需要多读一列/一排像素
    bool extraColumn = (width & 1);
    bool extraRow = (height & 1);

    if (extraColumn)
    {
        depth = _InputTexture.GatherRed(sampler_LinearClamp, uv, int2(1, 0));

        // 需要取右侧两个像素的结果，xyzw 的顺序参考下面的链接
        // https://wojtsterna.blogspot.com/2018/02/directx-11-hlsl-gatherred.html
        nearest = GetNearestDepth(nearest, GetNearestDepth(depth.y, depth.z));
    }

    if (extraRow)
    {
        depth = _InputTexture.GatherRed(sampler_LinearClamp, uv, int2(0, 1));

        // 需要取下侧两个像素的结果，xyzw 的顺序参考下面的链接
        // https://wojtsterna.blogspot.com/2018/02/directx-11-hlsl-gatherred.html
        nearest = GetNearestDepth(nearest, GetNearestDepth(depth.x, depth.y));
    }

    if (extraColumn && extraRow)
    {
        // 获取 3x3 区域右下角的像素
        nearest = GetNearestDepth(nearest, _InputTexture.Load(int3(location + 2, 0)).r);
    }

    _OutputTexture[dtid.xy] = nearest;
}
