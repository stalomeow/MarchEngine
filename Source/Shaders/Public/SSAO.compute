#pragma kernel SSAOMain

#include "Includes/Common.hlsl"
#include "Includes/GBuffer.hlsl"

#define SAMPLE_COUNT 14

// 方向固定为 8 cube corners + 6 centers of cube faces
// 但是模长是 [0.25, 1.0] 内随机的
static const float4 _BaseSampleDirections[SAMPLE_COUNT] =
{
    float4(0.144879 , 0.144879 , 0.144879 , 0),
    float4(-0.388377, -0.388377, -0.388377, 0),
    float4(-0.228041, 0.228041 , 0.228041 , 0),
    float4(0.494532 , -0.494532, -0.494532, 0),
    float4(0.397654 , 0.397654 , -0.397654, 0),
    float4(-0.352129, -0.352129, 0.352129 , 0),
    float4(-0.296018, 0.296018 , -0.296018, 0),
    float4(0.532301 , -0.532301, 0.532301 , 0),
    float4(-0.867130, 0.000000 , 0.000000 , 0),
    float4(0.809954 , 0.000000 , 0.000000 , 0),
    float4(0.000000 , -0.380581, 0.000000 , 0),
    float4(0.000000 , 0.894208 , 0.000000 , 0),
    float4(0.000000 , 0.000000 , -0.782876, 0),
    float4(0.000000 , 0.000000 , 0.635151 , 0),
};

cbuffer cbSSAO
{
    float _OcclusionRadius;
    float _OcclusionFadeStart;
    float _OcclusionFadeEnd;
    float _SurfaceEpsilon;
};

Texture2D _RandomVecMap;
RWTexture2D<float> _SSAOMap;

float OcclusionFunction(float distZ)
{
    float occlusion = saturate((_OcclusionFadeEnd - distZ) / (_OcclusionFadeEnd - _OcclusionFadeStart));
    return step(_SurfaceEpsilon, distZ) * occlusion; // distZ >= _SurfaceEpsilon ? occlusion : 0
}

[numthreads(8, 8, 1)]
void SSAOMain(uint3 dtid : SV_DispatchThreadID)
{
    float width, height;
    _SSAOMap.GetDimensions(width, height);
    float2 uv = dtid.xy / float2(width, height);

    GBufferData gbuffer = SampleGBufferData(uv);
    float3 p = ComputeViewSpacePosition(uv, gbuffer.depth);
    float3 n = TransformWorldToViewNormal(gbuffer.normalWS);
    float3 randVec = _RandomVecMap.SampleLevel(sampler_LinearRepeat, 4.0 * uv, 0).xyz * 2.0 - 1.0;

    float occlusionSum = 0;

    [unroll]
    for (int i = 0; i < SAMPLE_COUNT; ++i)
    {
        float3 offset = reflect(_BaseSampleDirections[i].xyz, randVec);
        float flip = sign(dot(offset, gbuffer.normalWS));

        float3 samplePosVS = p + flip * _OcclusionRadius * offset;
        float4 samplePosCS = TransformViewToHClip(samplePosVS);
        float2 sampleUV = samplePosCS.xy / samplePosCS.w * 0.5 + 0.5;
        sampleUV.y = 1.0 - sampleUV.y; // uv starts at top

        GBufferData sampleGBuffer = SampleGBufferData(sampleUV);
        float3 r = ComputeViewSpacePosition(sampleUV, sampleGBuffer.depth);

        float dp = max(dot(gbuffer.normalWS, normalize(r - p)), 0.0);
        occlusionSum += dp * OcclusionFunction(p.z - r.z);
    }

    _SSAOMap[dtid.xy] = 1.0 - occlusionSum / SAMPLE_COUNT;
}
